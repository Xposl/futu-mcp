"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const assert_1 = __importStar(require("assert"));
const user_config_json_1 = __importDefault(require("../../user_config.json"));
const futu_1 = __importDefault(require("../futu"));
const proto_1 = require("../proto/proto");
async function AssertShouldResolve(block, message) {
    try {
        if (typeof block === 'function') {
            return await block();
        }
        else if (block instanceof Promise) {
            return await block;
        }
        else {
            throw new Error('Unknown parameter');
        }
    }
    catch (err) {
        throw new assert_1.AssertionError({
            actual: err.toString(),
            expected: 'No rejection',
            operator: 'vs',
            message
        });
    }
}
const ft = new futu_1.default(user_config_json_1.default);
describe('Futu', () => {
    before(async () => {
        await ft.ready;
    });
    it('qotGetStaticInfo', async () => {
        let res = await AssertShouldResolve(ft.qotGetStaticInfo({
            market: proto_1.Qot_Common.QotMarket.QotMarket_HK_Security,
            secType: proto_1.Qot_Common.SecurityType.SecurityType_Warrant
        }), 'qotGetStaticInfo Failed');
        assert_1.default.ok(res.staticInfoList);
    });
    it('qotGetTradeDate', async () => {
        let res = await AssertShouldResolve(ft.qotGetTradeDate({
            market: proto_1.Qot_Common.QotMarket.QotMarket_HK_Security,
            beginTime: '2018-01-01 00:00:00',
            endTime: '2018-02-01 00:00:00'
        }), 'qotGetTradeDate Failed');
        assert_1.default.ok(res.tradeDateList);
        assert_1.default.deepEqual(res.tradeDateList.length, 23);
    });
    it('qotGetSecuritySnapshot', async () => {
        const targetSecurity = {
            code: '00700',
            market: proto_1.Qot_Common.QotMarket.QotMarket_HK_Security
        };
        let res = await AssertShouldResolve(ft.qotGetSecuritySnapshot({
            securityList: [targetSecurity]
        }), 'qotGetSecuritySnapshot Failed');
        assert_1.default.ok(res.snapshotList);
        assert_1.default.deepEqual(res.snapshotList.length, 1);
        assert_1.default.deepEqual(res.snapshotList[0].basic.security.code, targetSecurity.code);
        assert_1.default.deepEqual(res.snapshotList[0].basic.security.market, targetSecurity.market);
    });
    it('qotRequestHistoryKL', async () => {
        const targetSecurity = {
            code: '00700',
            market: proto_1.Qot_Common.QotMarket.QotMarket_HK_Security
        };
        let res = await AssertShouldResolve(ft.qotRequestHistoryKL({
            beginTime: '2020-01-01 00:00:00',
            endTime: '2020-01-10 00:00:00',
            klType: proto_1.Qot_Common.KLType.KLType_Day,
            rehabType: proto_1.Qot_Common.RehabType.RehabType_Forward,
            security: targetSecurity,
        }), 'qotRequestHistoryKL Failed');
        assert_1.default.ok(res.klList);
        assert_1.default.deepEqual(res.klList.length, 7);
        assert_1.default.ok(res.security);
        assert_1.default.deepEqual(res.security.code, targetSecurity.code);
        assert_1.default.deepEqual(res.security.market, targetSecurity.market);
    });
    it('trdGetMaxTrdQtys', async () => {
        let res = await AssertShouldResolve(ft.trdGetMaxTrdQtys({
            orderType: proto_1.Trd_Common.OrderType.OrderType_Normal,
            code: '00700',
            price: 100000
        }), 'trdGetMaxTrdQtys Failed');
        assert_1.default.ok(res.maxTrdQtys);
    });
    it('trdPlaceOrder & trdModifyOrder', async () => {
        let orderID;
        {
            let res = await AssertShouldResolve(ft.trdPlaceOrder({
                code: '00700',
                orderType: proto_1.Trd_Common.OrderType.OrderType_AbsoluteLimit,
                qty: 100,
                trdSide: proto_1.Trd_Common.TrdSide.TrdSide_Buy,
                price: 1.0,
                secMarket: proto_1.Trd_Common.TrdSecMarket.TrdSecMarket_HK
            }), 'trdPlaceOrder Failed');
            assert_1.default.ok(res.orderID);
            orderID = res.orderID;
        }
        await new Promise(resolve => setTimeout(resolve, 100));
        {
            let res = await AssertShouldResolve(ft.trdModifyOrder({
                modifyOrderOp: proto_1.Trd_Common.ModifyOrderOp.ModifyOrderOp_Delete,
                orderID
            }), 'trdModifyOrder Failed');
            assert_1.default.ok(res.orderID);
        }
    });
    it('qotSub', async () => {
        let tickerCount = 0, rtCount = 0;
        const targetSecurity = {
            code: 'YMmain',
            market: proto_1.Qot_Common.QotMarket.QotMarket_US_Security
        };
        ft.on(proto_1.Qot_Common.SubType.SubType_Ticker, targetSecurity, data => {
            assert_1.default.deepEqual(data.security.code, targetSecurity.code);
            assert_1.default.deepEqual(data.security.market, targetSecurity.market);
            ++tickerCount;
        });
        ft.on(proto_1.Qot_Common.SubType.SubType_RT, targetSecurity, data => {
            assert_1.default.deepEqual(data.security.code, targetSecurity.code);
            assert_1.default.deepEqual(data.security.market, targetSecurity.market);
            ++rtCount;
        });
        await AssertShouldResolve(ft.qotSub({
            isSubOrUnSub: true,
            isRegOrUnRegPush: true,
            subTypeList: [proto_1.Qot_Common.SubType.SubType_Ticker, proto_1.Qot_Common.SubType.SubType_RT],
            regPushRehabTypeList: [proto_1.Qot_Common.RehabType.RehabType_Forward],
            securityList: [targetSecurity]
        }), 'qotSub Failed');
        await new Promise(resolve => setTimeout(resolve, 60500));
        await ft.qotSub({
            isSubOrUnSub: false,
            subTypeList: [proto_1.Qot_Common.SubType.SubType_Ticker],
            isRegOrUnRegPush: false,
            securityList: [targetSecurity]
        });
        let tickerCountLap = tickerCount, rtCountLap = rtCount;
        await new Promise(resolve => setTimeout(resolve, 3000));
        await ft.qotSub({
            isSubOrUnSub: false,
            isRegOrUnRegPush: false,
            isUnsubAll: true
        });
        let rtCountLap2 = rtCount;
        await new Promise(resolve => setTimeout(resolve, 3000));
        assert_1.default.ok(tickerCount > 0);
        assert_1.default.ok(rtCount > 0);
        assert_1.default.deepEqual(tickerCountLap, tickerCount);
        assert_1.default.ok(rtCountLap < rtCount);
        assert_1.default.ok(rtCountLap < rtCountLap2);
        assert_1.default.deepEqual(rtCountLap2, rtCount);
    }).timeout(75000);
    after(async () => {
        ft.close();
    });
});
