"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("./utils/object");
const assert_1 = __importDefault(require("assert"));
const bytebuffer_1 = __importDefault(require("bytebuffer"));
const loglevel_1 = __importDefault(require("loglevel"));
const ws_1 = __importDefault(require("ws"));
const proto_1 = __importDefault(require("./proto/proto"));
const protoid_json_1 = __importDefault(require("./proto/protoid.json"));
const push_emitter_1 = __importDefault(require("./push_emitter"));
const types_1 = require("./types/types");
const error_1 = require("./utils/error");
const init_promise_1 = __importDefault(require("./utils/init_promise"));
const proto_2 = require("./utils/proto");
const HeadSign = "ft-v1.0\0";
const HeadLength = 44;
class WebSocket extends push_emitter_1.default {
    constructor(config, callback) {
        super();
        this.config = config;
        this.callback = callback;
        this.locks = {};
        this.onPushListeners = {};
        this.isLoggedIn = false;
        this.exitFlag = false;
        this.reqId = 1;
        this.ws = this.setup();
        this.initPromise = new init_promise_1.default();
    }
    get ready() {
        return this.initPromise.isReady;
    }
    addOnPushListener(cmdOrName, security, listener) {
        let cmd = -1;
        if (typeof cmdOrName === 'string') {
            if (proto_1.default[cmdOrName]) {
                cmd = protoid_json_1.default[cmdOrName];
            }
            else if (!isNaN(parseInt(cmdOrName))) {
                cmd = parseInt(cmdOrName);
            }
            else {
                throw new error_1.ParameterError('Invalid cmd');
            }
        }
        else if (proto_2.ProtoName[cmdOrName]) {
            cmd = cmdOrName;
        }
        else {
            throw new error_1.ParameterError('Invalid cmd');
        }
        if (!this.onPushListeners[cmd]) {
            this.onPushListeners[cmd] = {
                [`${security.code}|${security.market}`]: [listener]
            };
        }
        else if (!this.onPushListeners[cmd][`${security.code}|${security.market}`]) {
            this.onPushListeners[cmd][`${security.code}|${security.market}`] = [listener];
        }
        else {
            this.onPushListeners[cmd];
        }
    }
    setup() {
        if (this.ws) {
            this.ws.onopen = this.ws.onmessage = this.ws.onerror = this.ws.onclose = null;
        }
        this.ws = new ws_1.default(`${this.config.isSSL ? 'wss' : 'ws'}://${this.config.ip}:${this.config.port}`);
        this.ws.sendCmd = this.sendCmd.bind(this);
        this.ws.onopen = this.onOpen.bind(this);
        this.ws.onmessage = this.releaseLock.bind(this);
        this.ws.onerror = this.onError.bind(this);
        this.ws.onclose = this.onClose.bind(this);
        this.reconnectTimer = undefined;
        return this.ws;
    }
    close() {
        this.exitFlag = true;
        this.clean();
    }
    sendCmd(cmd, buffer) {
        const reqId = ++this.reqId;
        return new Promise((resolve, reject) => {
            let timeoutTimer, isHandled = false;
            this.ws.send(this.pack(cmd, reqId, buffer).toArrayBuffer(), err => {
                if (timeoutTimer)
                    clearTimeout(timeoutTimer);
                if (!this.locks[reqId] && !isHandled) {
                    isHandled = true;
                    if (err)
                        return reject(err);
                    this.locks[reqId] = (err, data) => {
                        if (err)
                            return reject(err);
                        if (!data) {
                            return reject(new error_1.FutuError('Return obj is undefined'));
                        }
                        else if (data.error !== 0) {
                            return reject(new error_1.FutuError(data.errMsg));
                        }
                        else if (data.sign.indexOf(HeadSign) === -1) {
                            return reject(new error_1.FutuError('Wrong Header Flag'));
                        }
                        else {
                            return resolve(data.data);
                        }
                    };
                }
            });
            timeoutTimer = setTimeout(() => {
                if (!isHandled) {
                    isHandled = true;
                    reject(new Error('Timeout'));
                }
            }, this.config.reqTimeout);
        });
    }
    request(name, req) {
        var _a;
        if (this.isLoggedIn) {
            const _req = Object.assign({}, req, {
                packetID: {
                    connID: this.connID,
                    serialNo: Date.now()
                },
                header: this.header,
                userID: this.config.userID,
                accIDList: [(_a = this.header) === null || _a === void 0 ? void 0 : _a.accID]
            });
            return this._request(name, _req);
        }
        else {
            throw new error_1.SystemError('Connection is not ready yet');
        }
    }
    async _request(name, req) {
        const proto = proto_1.default[name];
        assert_1.default.ok(!proto.Request || req, 'Request obj is required');
        if (proto.Request) {
            if (proto.C2S) {
                const errMsg = proto.C2S.verify(req);
                if (errMsg)
                    throw new error_1.ParameterError(errMsg);
            }
            else {
                throw new error_1.ParameterError('Cannot get C2S class by this name');
            }
            const buffer = proto.Request.encode({
                c2s: req
            }).finish(), response = await this.ws.sendCmd(protoid_json_1.default[name], buffer), retObj = proto.Response.decode(new Uint8Array(response));
            if (retObj.errCode === 0 && retObj.retType !== -1) {
                return retObj.s2c;
            }
            else {
                throw new error_1.FutuError(retObj.retMsg);
            }
        }
        throw new error_1.ParameterError('Cannot get request class by this name');
    }
    async onOpen(_) {
        if (this.ws) {
            this.clean(false);
            let keyMD5 = undefined;
            if (this.config.wsKey) {
                keyMD5 = this.config.wsKey;
            }
            try {
                await this._request('InitWebSocket', {
                    websocketKey: keyMD5
                });
                await this._request('Trd_UnlockTrade', {
                    pwdMD5: this.config.pwdMd5,
                    unlock: true
                });
                const { accList } = await this._request('Trd_GetAccList', {
                    userID: this.config.userID
                });
                if (!accList || accList.length === 0)
                    throw new error_1.SystemError('Cannot get acc list');
                const matchedAcc = accList.find(acc => acc.trdEnv === this.config.accEnv &&
                    acc.trdMarketAuthList.includes(this.config.accMarket) &&
                    acc.accType === this.config.accType);
                if (!matchedAcc)
                    throw new error_1.SystemError('No matched account');
                this.header = {
                    trdEnv: this.config.accEnv,
                    accID: matchedAcc.accID,
                    trdMarket: this.config.accMarket
                };
                super.accID = matchedAcc.accID;
                const { connID, qotLogined, trdLogined } = (await this._request('GetGlobalState', {
                    userID: this.config.userID
                }));
                if (!connID)
                    throw new error_1.SystemError('Cannot get connID');
                this.connID = connID;
                this.isLoggedIn = qotLogined && trdLogined;
                if (!this.isLoggedIn)
                    throw new error_1.SystemError('Either API for Quote and Trade is not permitted');
                await this.initPromise.resolve();
                this.callback();
                loglevel_1.default.info('Finish initialization');
            }
            catch (err) {
                loglevel_1.default.error(err);
                this.exitFlag = true;
                this.clean();
                loglevel_1.default.warn('Closing');
            }
        }
    }
    onError(e) {
        if (this.exitFlag) {
            loglevel_1.default.warn('Websocket disconnected');
            loglevel_1.default.warn('Closing');
        }
        else {
            loglevel_1.default.error('Error occured', e);
            if (!this.reconnectTimer) {
                this.clean();
                this.reconnectTimer = setTimeout(() => this.setup(), 1000);
            }
        }
    }
    onClose(_) {
        if (this.exitFlag) {
            loglevel_1.default.warn('Websocket disconnected');
            loglevel_1.default.warn('Closing');
        }
        else {
            loglevel_1.default.error('Websocket disconnected');
            if (!this.reconnectTimer) {
                this.clean();
                this.reconnectTimer = setTimeout(() => this.setup(), 1000);
            }
        }
    }
    _onPush(res) {
        const proto = proto_1.default[proto_2.ProtoName[res.cmd]];
        if (proto.Response) {
            const retObj = proto.Response.decode(new Uint8Array(res.data));
            if (retObj.errCode === 0 && retObj.retType !== -1) {
                return super.onPush(res.cmd, retObj.s2c);
            }
            else {
                throw new error_1.FutuError(retObj.retMsg);
            }
        }
        else {
            loglevel_1.default.warn('Cannot decode this received msg', res);
        }
    }
    releaseLock(msg) {
        const { data } = msg;
        if (data && data instanceof Buffer) {
            const ret = this.unpack(data);
            if (ret && ret.section && this.locks[ret.section]) {
                this.locks[ret.section](undefined, ret);
                delete this.locks[ret.section];
            }
            else if (ret.cmd === types_1.WsApiCmd.OpenDisConnect) {
                if (!this.exitFlag) {
                    loglevel_1.default.error('Disconnected (Cmd = 2)');
                    if (!this.reconnectTimer) {
                        this.clean();
                        this.reconnectTimer = setTimeout(() => this.setup(), 1000);
                    }
                }
            }
            else {
                this._onPush(ret);
            }
        }
    }
    pack(id, requestId, payload) {
        const buf = new bytebuffer_1.default();
        buf.writeUTF8String(HeadSign);
        buf.writeUint32(id);
        buf.writeUint64(requestId);
        buf.append(payload);
        buf.flip();
        return buf;
    }
    unpack(data) {
        var buf = new bytebuffer_1.default(data.byteLength, false);
        let result = {};
        buf.append(data);
        buf.flip();
        result.sign = buf.readUTF8String(8);
        result.cmd = buf.readUint32();
        result.section = buf.readUint64().toNumber();
        result.error = buf.readInt32();
        result.errMsg = buf.readUTF8String(20).replace(/\0/g, '');
        if (data.byteLength > HeadLength) {
            result.data = buf.readBytes(data.byteLength - HeadLength).toArrayBuffer();
        }
        return result;
    }
    clean(close = true) {
        var _a;
        const closeError = new error_1.SystemError('Closing websocket connection');
        Object.values(this.locks).forEach(lock => lock(closeError));
        this.locks = [];
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
        }
        (_a = super.emitter) === null || _a === void 0 ? void 0 : _a.removeAllListeners();
        if (close) {
            this.initPromise.reset();
            try {
                this.ws.close();
            }
            catch (e) { }
        }
        this.isLoggedIn = false;
    }
}
exports.default = WebSocket;
